# @salutejs/cerate-app
Шаблонизатор проектов

Простейший способ получить заготовку проекта это выполнить команду


```bash
npx @salutejs/cerate-app
```

После запуска появится визард, в котором можно указать имя проекта и прочие опции. После завершения работы скрипта в текущей рабоче директории терминала будет создана еще одна директория с именем указанным как имя проекта.


### Параметр `--templatePackage`
При запуске команды без аргументов будет выбран пакет `@salutejs/canvas-example` как пакет-шаблон. Но можно указать в качестве шаблона любой другой пакет. При отсутствии дополнительной конфигурации пакет-шаблон будет просто скопирован в целевую папку.

```bash
npx @salutejs/cerate-app --templatePackage any-npm-package
```

Если ваш пакет требует авторизации в npm, можно задать токен доступа в env-переменную `NPM_REGISTRY_TOKEN`.

## Создание своего шаблона


`@salutejs/cerate-app` не привязан ни к какому конкретному шаблона, хотя и создавался, чтобы удовлетворить потребностям шаблонов `@salutejs`. За счет этого можно достаточно просто создавать свои шаблоны. В простейшем виде шаблоном является любой npm-пакет, в этом можно убедится вызвав `npx @salutejs/cerate-app --templatePackage lodash`. В этом случа `@salutejs/cerate-app` просто скопирует все файлы пакета в целевую папку.

Но такие шаблоны не имеют особого смысла, они лишь упрощают копирование пакета, поэтому существует специальный API позволяющий более тонко настраивать шаблоны. Для использования этого API необходимо создать папку `./.create-app/` в корне пакета-шаблона и файл `index.mjs` в этой папке. В простейшем виде это может быть пустой файл. Помимо этого все файлы прогоняются через [mustache](https://mustache.github.io/mustache.5.html).

![2](https://user-images.githubusercontent.com/17454987/172394436-996e6b30-874e-49ec-b11a-fa2b2cbbb685.png)

### Директивы шаблонизации

Все копируемые из шаблона файлы прогоняются через [mustache](https://mustache.github.io/mustache.5.html), при это сами директивы переопределены таким образом, чтобы оставаться просто комментариями для исходного кода, оставляя исходные файлы валидным javascript-кодом (префикс директивы `{{` заменен на `/* <|`, а постфикс `}}` на `|> */`), чтобы шаблон можно было запускать и тестировать без шага предварительной шаблониазации. При этом можно задать и свои правила для любых файлов при помощи [поля rules](#rules) конфига.

Например строка, обернутая в приведенные ниже директивы будет присуствовать в конечном файле если включен `featureToggle` с `id` равным `imageOptimization` или отсутствовать в противном случае.

```js
    /* <|#imageOptimization|> */
    { href: `${basePath}/image-optimization`, content: 'Оптимизация изображений' },
    /* <|/imageOptimization|> */
```

На оригинальном синтаксисе mustache это выглядело бы так

```js
    {{#imageOptimization}}
    { href: `${basePath}/image-optimization`, content: 'Оптимизация изображений' },
    {{/imageOptimization}}
```

### Описание конфига

Более тонкая настройка осуществляется с помощью экспортирования переменных из файла конфига, их более подробное описание ниже, а [развернутый пример можно посмотреть в этом репозитории](./test/__mock__/template-package/.create-app/index.mjs).

#### templateDescription

Текстовое описание шаблона. Будет показано пользователю сразу после запуска `@salutejs/cerate-app`.
```js
export templateDescription = "Описание шаблона";
```

#### featureToggles

Если необходимо, чтобы пользователь мог выбрать из некого списка дполнительных возможностей (`featureToggle`) шаблона, нужно экспортировать переменную featureToggles, которая представляет из себя массив объектов вида.

```js
{
    featureId: 'imageOptimization',
    name: `Оптимизация изображений
    Для более быстрой загрузки изображений next использует изображения
    правильного формата и размера. В примере так же используется аватарница
    sberdevices, что является целевой картиной для использования изображений`,
    defaultValue: true,
    hidden: false,
}
```

![1](https://user-images.githubusercontent.com/17454987/172394448-d4ba47ac-e710-4773-be83-063bdbc31451.png)

При этом сам по себе массив ничего не делает, лишь отвечает за показанный пользователю интерфейс и сбор ответов пользователя. На этапе выполнения визарда появится вопрос про изменение дефолтных опций, если пользователь ответит на него положительно, то тогда он сможет изменить включенность/выключенность `featureToggle`.

 * **featureId** - проивзоьлный уникальный идентификатор `featureToggle`
 * **name** - название `featureToggle`, для большей ясности можно добавить к нему дополнительное описание через символ переноса строки. Важно помнить про то, что ширина терминала пользователя может быть достаточно маленькой, желательно форматировать описание так, чтобы длина каждой отдельтной сртоки была не больше 80 символов
 * **defaultValue** - должен ли `featureToggle` быть включенным или выключенным по умолчанию
 * **hidden** - если `true`, то скрывает от пользователя `featureToggle`

#### featureConfigMap

Основная часть конфига. После того, как пользователь выбрал необходимые ему `featureToggle` эта часть конфига позволяет `@salutejs/cerate-app` на основе этих ответов принять решение, какие модификаторы (`featureConfig`) необходимо применить к шаблону.

В простейшем случае достаточно соотвествия "один к одному", то есть одному `featureToggle` соответсвует ровно один `featureConfig` но в реальных примерах это не всегда так, поэтому `featureConfigMap` реализует более сложный приницип установки соотвествия. Переменная `featureConfigMap` представялет из себя объект, ключами которого являются уникальные удентификаторы `featureConfig`, а значениями другой объект вида

```js
{
    'imageOptimizationConfigId' :{
        config: (options) => getImageOptimizationConfig(options),
        test: (selectedFeatureToggleIds) => selectedFeatureToggleIds.include('imageOptimization'),
    }
    /* ... */
}
```
 * **imageOptimizationConfigId** - в данном примере это произвольный уникальный идентификатор `featureConfig`
 * **config** - функция, принимающая набор некоторых опций и возвращаю готовый featureConfig (должна быть определена автором шаблона)
    * **options.templatePath** - абсолютный путь до текущей папки пакета-шаблона, можно использовать как префикс для всех путей, которые хотелось бы не указвать как абсодютный (см. пример ниже).
 * **test** - функция, которая по выбранным пользователем `featureToggle` определяет, нужно ли применить текущий `featureConfig` к шаблону (`on`) или нет (`off`). В простейшем случае соответствия "один к одному" можно просто проверить что соотвествующий `featureToggle` есть в массиве `selectedFeatureToggleIds`.

Сам `featureConfig`, который должен быть возвращен функцией `config` имеет следующий вид

```js
{
    off: {
        sourceAddon: [
            `!${templatePath}src/components/PageImageOptimization.tsx`,
        ],
        
        jsonChanges: [
            {
                glob: `${templatePath}package.json`,
                changes: {
                    remove: ['scripts.build:static'],
                    merge: {
                        scripts: {
                            build: 'next build && next export',
                        },
                    },
                },
            },
        ],
    },
    on: {
        sourceAddon: [],
        jsonChanges: [],
    },
}

```

Основной упор в `@salutejs/cerate-app` сделан на то, что пакет-шаблон может оставаться запускаемым пакетом и валидным с точки зрения javascript. Поэтому в объекте конфига есть 2 способа повлиять на состав файлов проекта, который получится после шаблонизации: если конфиг включен (`on`) и если конфиг выключен (`off`).

 * **off** - это та часть конфига, которая будет пременена, если функция `test` вернула `false`.
    * `sourceAddon` - массив `glob`-паттернов, который говорит какие файлы нужно добавить или исключить при применении этой части конфига, в примере из общего списка файлов убирается файл `PageImageOptimization.tsx`.
    * `jsonChanges` - это поле необходимо только потому, что JSON как формат лишен комментариев и невозможно добавить внутрь JSON-файла [директивы шаблонизации](#директивы-шаблонизации) с помощью комментариев. Принимает массив объектов в которых 
        * **glob** - `glob`-паттерн который выбирает файлы, к которым будут применены изменения из поля `changes`
        * **changes** - объект, описывающий, какие поля в JSON-файле надо удалить (поле `remove`), а какие изменить/добавить (поле `merge`). Поле `remove` подразумевает массив строк, каждая из которых задает путь до поля (в примере удаляется поле `build:static` из объекта `scripts` в `package.json`), а поле `merge` предоставляет объект для объединения с определенным в JSON объектом ([lodash merge](https://lodash.com/docs/#merge))).
 * **on** - это та часть конфига, которая будет пременена, если функция `test` вернула `true` (такие же поля как и для `off`)

На практике шаблон часто представляет из себя макисамльный пример со всеми файлами, и важнее убирать из него файлы, когда какая-то функциональность не нужна, чем наоброт.

#### rules
В случае если нужно доопределить или переопределить для каких-то файлов стиль комментария, служащим директивой шаблонизации (например для файлов без расширения), необходимо экспортировать переменную rules, представляющую из себя массив объектов вида 

```js
{
    test: (file) => ['.env.production', '.env.development', '.gitignore']
        .includes(file.basename),
    tags: ['# <|', '|> #'],
},
```

 * **test** - функция, принимающая в себя файл (`file`) в терминах [vinyl-fs](https://github.com/gulpjs/vinyl#instance-methods) и возвращающая `true`, для файлов, к которым нужно применять указанные тэги как префикс/постфикс директивы шаблонизации.
 * **tags** - префикс (первый элемент) и постфикс (второй элемнет) директив шаблониазции
